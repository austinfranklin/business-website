<!DOCTYPE html>
<html lang="en">
<head>
<meta charset="UTF-8">
<title>Draw Your Own Oscillator</title>
<style>
  body {
    background: #111;
    color: white;
    font-family: sans-serif;
    text-align: center;
    margin: 0;
    padding: 0;
  }
  #drawCanvas {
    border: 2px solid #555;
    display: block;
    margin: 20px auto;
    background: black;
    touch-action: none;
  }
  button {
    background: #333;
    color: white;
    border: none;
    padding: 10px 20px;
    margin: 5px;
    font-size: 16px;
    cursor: pointer;
    border-radius: 4px;
  }
  button:hover {
    background: #555;
  }
</style>
</head>
<body>

<h1>Draw Your Waveform</h1>
<canvas id="drawCanvas" width="800" height="200"></canvas><br>
<button id="clearBtn">Clear</button>
<button id="playBtn">Play</button>
<button id="stopBtn">Stop</button>

<script>
const canvas = document.getElementById("drawCanvas");
const ctx = canvas.getContext("2d");
let drawing = false;
let points = []; // store all drawn points
let audioCtx, osc, gainNode;

// Draw stored waveform
function redraw() {
  ctx.fillStyle = "black";
  ctx.fillRect(0, 0, canvas.width, canvas.height);
  ctx.strokeStyle = "lime";
  ctx.lineWidth = 2;
  ctx.beginPath();
  for (let i = 0; i < points.length; i++) {
    const [x, y] = points[i];
    if (i === 0) {
      ctx.moveTo(x, y);
    } else {
      ctx.lineTo(x, y);
    }
  }
  ctx.stroke();
}

function getMousePos(e) {
  const rect = canvas.getBoundingClientRect();
  return {
    x: e.clientX - rect.left,
    y: e.clientY - rect.top
  };
}

function getTouchPos(e) {
  const rect = canvas.getBoundingClientRect();
  const touch = e.touches[0];
  return {
    x: touch.clientX - rect.left,
    y: touch.clientY - rect.top
  };
}

// Mouse/touch events
canvas.addEventListener("mousedown", e => {
  drawing = true;
  const pos = getMousePos(e);
  points.push([pos.x, pos.y]);
  redraw();
});
canvas.addEventListener("mousemove", e => {
  if (!drawing) return;
  const pos = getMousePos(e);
  points.push([pos.x, pos.y]);
  redraw();
});
canvas.addEventListener("mouseup", () => drawing = false);
canvas.addEventListener("mouseleave", () => drawing = false);

canvas.addEventListener("touchstart", e => {
  e.preventDefault();
  drawing = true;
  const pos = getTouchPos(e);
  points.push([pos.x, pos.y]);
  redraw();
});
canvas.addEventListener("touchmove", e => {
  e.preventDefault();
  if (!drawing) return;
  const pos = getTouchPos(e);
  points.push([pos.x, pos.y]);
  redraw();
});
canvas.addEventListener("touchend", () => drawing = false);

// Clear
document.getElementById("clearBtn").addEventListener("click", () => {
  points = [];
  redraw();
});

// Convert drawing to waveform and play
document.getElementById("playBtn").addEventListener("click", () => {
  if (points.length < 2) return;

  if (!audioCtx) audioCtx = new (window.AudioContext || window.webkitAudioContext)();

  // Resample drawing into a Float32Array
  const tableSize = 2048;
  const waveform = new Float32Array(tableSize);
  for (let i = 0; i < tableSize; i++) {
    const t = i / (tableSize - 1);
    const xPos = t * (canvas.width - 1);
    // find nearest point in drawn data
    let closest = points.reduce((a, b) => {
      return Math.abs(b[0] - xPos) < Math.abs(a[0] - xPos) ? b : a;
    });
    const normY = 1 - (closest[1] / canvas.height); // 0..1
    waveform[i] = (normY - 0.5) * 2; // -1..1
  }

  // Apply crossfade at loop boundaries (50 samples)
  const fadeLen = 50;
  for (let i = 0; i < fadeLen; i++) {
    const fadeIn = i / fadeLen;
    const fadeOut = 1 - fadeIn;
    const startVal = waveform[i];
    const endVal = waveform[tableSize - fadeLen + i];
    const avg = startVal * fadeIn + endVal * fadeOut;
    waveform[i] = avg;
    waveform[tableSize - fadeLen + i] = avg;
  }

  // Create periodic wave
  const periodicWave = audioCtx.createPeriodicWave(waveform, new Float32Array(tableSize), { disableNormalization: true });

  // Create oscillator and gain envelope
  osc = audioCtx.createOscillator();
  gainNode = audioCtx.createGain();
  osc.setPeriodicWave(periodicWave);
  gainNode.gain.setValueAtTime(0, audioCtx.currentTime);
  gainNode.gain.linearRampToValueAtTime(0.8, audioCtx.currentTime + 0.02); // short fade-in
  gainNode.gain.linearRampToValueAtTime(0.8, audioCtx.currentTime + 1e6); // hold level

  osc.connect(gainNode).connect(audioCtx.destination);
  osc.start();
});

// Stop
document.getElementById("stopBtn").addEventListener("click", () => {
  if (osc) {
    gainNode.gain.cancelScheduledValues(audioCtx.currentTime);
    gainNode.gain.setValueAtTime(gainNode.gain.value, audioCtx.currentTime);
    gainNode.gain.linearRampToValueAtTime(0, audioCtx.currentTime + 0.02); // fade out
    osc.stop(audioCtx.currentTime + 0.03);
    osc = null;
  }
});

redraw();
</script>

</body>
</html>

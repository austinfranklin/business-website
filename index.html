<!DOCTYPE html>
<html lang="en">
<head>
  <meta charset="UTF-8" />
  <meta name="viewport" content="width=device-width, initial-scale=1.0"/>
  <title>Stackable Music Blocks</title>
  <style>
    html, body {
        margin: 0;
        padding: 0;
        background: #111;
        overflow: hidden;
        font-family: sans-serif;
        color: white;
    }
    canvas {
        display: block;
        background: #111;
    }
    #controls {
        position: absolute;
        top: 10px;
        left: 10px;
        z-index: 10;
    }
    #controls > * {
        display: block;
        margin-bottom: 6px;
    }
    .note-buttons {
        display: flex;
        flex-wrap: wrap;
        gap: 6px;
        margin-top: 6px;
    }

    .note-buttons button {
        flex: 1 1 60px;
        text-align: center;
    }
    button {
        background: #222;
        border: 1px solid #555;
        color: white;
        padding: 5px 10px;
        cursor: pointer;
    }
    button:hover {
        background: #333;
    }
  </style>
</head>
<body>
  <div id="controls">
    <label>
      Playhead Speed:
      <input type="range" id="speedSlider" min="1" max="50" value="10">
    </label>
    <button id="addBlock">Add Random Block</button>
    <button id="removeBlock">Remove Last Block</button>
    <div class="note-buttons" id="noteButtons"></div>
    <button id="clearBlocks">Clear Blocks</button>
  </div>

  <canvas id="canvas"></canvas>

  <script>
  const canvas = document.getElementById("canvas");
  const ctx = canvas.getContext("2d");
  let W = canvas.width = window.innerWidth;
  let H = canvas.height = window.innerHeight;

  window.addEventListener("resize", () => {
    W = canvas.width = window.innerWidth;
    H = canvas.height = window.innerHeight;
  });

  const BLOCK_SIZE = 60;
  const GRAVITY = 0.7;
  const FRICTION = 0.9;
  const BOUNCE = 0.2;
  const NOTE_DURATION_MS = 250;

  const notes = [
    261.63, 277.18, 293.66, 311.13, 329.63, 349.23,
    369.99, 392.00, 415.30, 440.00, 466.16, 493.88
  ];
  const noteNames = [
    "C", "C#", "D", "D#", "E", "F",
    "F#", "G", "G#", "A", "A#", "B"
  ];

  let playheadX = 0;
  let playSpeed = Number(document.getElementById("speedSlider").value);
  document.getElementById("speedSlider").addEventListener("input", (e) => {
    playSpeed = Number(e.target.value);
  });

  let audioCtx;
  function ensureAudio() {
    if (!audioCtx) audioCtx = new (window.AudioContext || window.webkitAudioContext)();
  }

  function playTone(freq) {
    ensureAudio();
    const osc = audioCtx.createOscillator();
    const gain = audioCtx.createGain();
    osc.frequency.value = freq;
    osc.type = "sine";
    gain.gain.setValueAtTime(0.3, audioCtx.currentTime);
    gain.gain.exponentialRampToValueAtTime(0.001, audioCtx.currentTime + NOTE_DURATION_MS / 1000);
    osc.connect(gain);
    gain.connect(audioCtx.destination);
    osc.start();
    osc.stop(audioCtx.currentTime + NOTE_DURATION_MS / 1000);
  }

  class Block {
    constructor(x, noteIdx) {
      this.x = x;
      this.y = Math.random() * H * 0.4;
      this.vx = 0;
      this.vy = 0;
      this.noteIdx = noteIdx;
      this.color = `hsl(${noteIdx * 30}, 100%, 60%)`;
      this.isDragging = false;
      this.dragOffsetX = 0;
      this.dragOffsetY = 0;
      this.playLock = false;
      this.highlightTimer = 0;
    }

    get bottom() {
      return this.y + BLOCK_SIZE;
    }

    get right() {
      return this.x + BLOCK_SIZE;
    }

    contains(mx, my) {
      return mx >= this.x && mx <= this.right && my >= this.y && my <= this.bottom;
    }

    intersectsPlayhead(px) {
      return px >= this.x && px <= this.x + BLOCK_SIZE;
    }

    update(blocks) {
      if (!this.isDragging) {
        this.vy += GRAVITY;
        let nextY = this.y + this.vy;
        let nextX = this.x + this.vx;

        for (let other of blocks) {
          if (other === this) continue;

          const collideX = nextX < other.x + BLOCK_SIZE && nextX + BLOCK_SIZE > other.x;
          const collideY = nextY < other.y + BLOCK_SIZE && nextY + BLOCK_SIZE > other.y;

          if (collideX && collideY) {
            if (this.vy > 0 && this.bottom <= other.y + 10) {
              this.vy = 0;
              this.y = other.y - BLOCK_SIZE;
            }
            if (this.vx !== 0) {
              if (this.x < other.x) {
                this.x = other.x - BLOCK_SIZE;
              } else {
                this.x = other.x + BLOCK_SIZE;
              }
              this.vx = 0;
            }
          }
        }

        if (this.bottom >= H) {
          this.y = H - BLOCK_SIZE;
          this.vy *= -BOUNCE;
          this.vx *= FRICTION;
        } else {
          this.y += this.vy;
        }

        if (this.x <= 0 || this.x + BLOCK_SIZE >= W) {
          this.vx *= -BOUNCE;
        }

        this.x += this.vx;
        this.vx *= 0.98;
        this.vy *= 0.98;
      }

      if (this.highlightTimer > 0) this.highlightTimer--;
    }

    draw() {
      ctx.save();
      if (this.highlightTimer > 0) {
        ctx.shadowColor = "white";
        ctx.shadowBlur = 20;
      }

      ctx.fillStyle = this.color;
      ctx.strokeStyle = "#fff";
      ctx.lineWidth = 2;
      ctx.beginPath();
      ctx.roundRect(this.x, this.y, BLOCK_SIZE, BLOCK_SIZE, 8);
      ctx.fill();
      ctx.stroke();

      ctx.fillStyle = "#fff";
      ctx.font = "bold 14px sans-serif";
      ctx.textAlign = "center";
      ctx.textBaseline = "middle";
      ctx.fillText(noteNames[this.noteIdx], this.x + BLOCK_SIZE / 2, this.y + BLOCK_SIZE / 2);

      ctx.restore();
    }
  }

  let blocks = [];
  function initBlocks() {
    blocks = [];
    for (let i = 0; i < 12; i++) {
      const x = (i + 1) * (W / 13) - BLOCK_SIZE / 2;
      blocks.push(new Block(x, i));
    }
  }

  function addRandomBlock(x = null, y = null) {
    const noteIdx = Math.floor(Math.random() * notes.length);
    const bx = x ?? Math.random() * (W - BLOCK_SIZE);
    const block = new Block(bx, noteIdx);
    if (y !== null) block.y = y;
    blocks.push(block);
  }

  function removeLastBlock() {
    blocks.pop();
  }

  document.getElementById("addBlock").addEventListener("click", () => {
    ensureAudio();
    addRandomBlock();
  });

  document.getElementById("removeBlock").addEventListener("click", () => {
    removeLastBlock();
  });

  const noteButtonsContainer = document.getElementById("noteButtons");
  noteNames.forEach((name, idx) => {
    const btn = document.createElement("button");
    btn.textContent = name;
    btn.addEventListener("click", () => {
      ensureAudio();
      const x = Math.random() * (W - BLOCK_SIZE);
      blocks.push(new Block(x, idx));
      playTone(notes[idx]);
    });
    noteButtonsContainer.appendChild(btn);
  });

  document.getElementById("clearBlocks").addEventListener("click", () => {
    blocks = [];
  });

  // Drag logic
  let draggingBlock = null;

  canvas.addEventListener("mousedown", (e) => {
    const mx = e.clientX;
    const my = e.clientY;
    for (let block of blocks.slice().reverse()) {
      if (block.contains(mx, my)) {
        draggingBlock = block;
        block.isDragging = true;
        block.dragOffsetX = mx - block.x;
        block.dragOffsetY = my - block.y;
        break;
      }
    }
  });

  canvas.addEventListener("mousemove", (e) => {
    if (draggingBlock) {
      draggingBlock.x = e.clientX - draggingBlock.dragOffsetX;
      draggingBlock.y = e.clientY - draggingBlock.dragOffsetY;
      draggingBlock.vx = 0;
      draggingBlock.vy = 0;
    }
  });

  canvas.addEventListener("mouseup", () => {
    if (draggingBlock) {
      draggingBlock.isDragging = false;
      draggingBlock = null;
    }
  });

  canvas.addEventListener("mouseleave", () => {
    if (draggingBlock) {
      draggingBlock.isDragging = false;
      draggingBlock = null;
    }
  });

  function animate() {
    ctx.clearRect(0, 0, W, H);

    playheadX += playSpeed;
    if (playheadX > W) playheadX = 0;

    for (let block of blocks) {
      block.update(blocks);

      if (block.intersectsPlayhead(playheadX) && !block.playLock) {
        block.playLock = true;
        block.highlightTimer = 10;
        playTone(notes[block.noteIdx]);
        setTimeout(() => {
          block.playLock = false;
        }, NOTE_DURATION_MS);
      }

      block.draw();
    }

    // Draw playhead
    ctx.strokeStyle = "red";
    ctx.beginPath();
    ctx.moveTo(playheadX, 0);
    ctx.lineTo(playheadX, H);
    ctx.stroke();

    requestAnimationFrame(animate);
  }

  initBlocks();
  animate();
</script>
</body>
</html>

<!DOCTYPE html>
<html lang="en">
<head>
  <meta charset="UTF-8" />
  <meta name="viewport" content="width=device-width, initial-scale=1.0"/>
  <title>Chromatic Musical Blocks</title>
  <style>
    body {
      margin: 0;
      background: #111;
      overflow: hidden;
      font-family: sans-serif;
    }

    canvas {
      display: block;
    }
  </style>
</head>
<body>
<canvas id="canvas"></canvas>

<script>
const NOTES = [
  'C4', 'C#4', 'D4', 'D#4', 'E4', 'F4',
  'F#4', 'G4', 'G#4', 'A4', 'A#4', 'B4'
];

const COLORS = [
  '#e74c3c', '#e67e22', '#f1c40f', '#2ecc71', '#1abc9c', '#3498db',
  '#9b59b6', '#34495e', '#16a085', '#8e44ad', '#d35400', '#c0392b'
];

const NOTE_FREQS = {
  'C4': 261.63, 'C#4': 277.18, 'D4': 293.66, 'D#4': 311.13,
  'E4': 329.63, 'F4': 349.23, 'F#4': 369.99, 'G4': 392.00,
  'G#4': 415.30, 'A4': 440.00, 'A#4': 466.16, 'B4': 493.88
};

const canvas = document.getElementById('canvas');
const ctx = canvas.getContext('2d');
let W = window.innerWidth;
let H = window.innerHeight;
canvas.width = W;
canvas.height = H;

const GRAVITY = 0.5;
const BLOCK_SIZE = 60;
const blocks = [];
const activePairs = new Map();
const audioCtx = new (window.AudioContext || window.webkitAudioContext)();

class Block {
  constructor(x, note, color) {
    this.x = x;
    this.y = Math.random() * H * 0.25;
    this.vy = 0;
    this.width = BLOCK_SIZE;
    this.height = BLOCK_SIZE;
    this.note = note;
    this.color = color;
    this.isDragging = false;
    this.dragOffset = {x: 0, y: 0};
  }

  draw() {
    ctx.fillStyle = this.color;
    ctx.fillRect(this.x, this.y, this.width, this.height);
    ctx.fillStyle = "#fff";
    ctx.font = "bold 16px sans-serif";
    ctx.fillText(this.note, this.x + 10, this.y + 35);
  }

  update() {
    if (!this.isDragging) {
      this.vy += GRAVITY;
      this.y += this.vy;

      // Floor collision
      if (this.y + this.height > H) {
        this.y = H - this.height;
        this.vy = 0;
      }

      // Stack collision
      for (let other of blocks) {
        if (other !== this && this.isCollidingWith(other)) {
          if (this.vy > 0) {
            this.y = other.y - this.height;
            this.vy = 0;
          }
        }
      }
    }
  }

  isCollidingWith(other) {
    return this.x < other.x + other.width &&
           this.x + this.width > other.x &&
           this.y < other.y + other.height &&
           this.y + this.height > other.y;
  }

  getIdWith(other) {
    return [this.note, other.note].sort().join("-");
  }
}

function playNotePair(id, note1, note2) {
  if (activePairs.has(id)) return;

  const freq1 = NOTE_FREQS[note1];
  const freq2 = NOTE_FREQS[note2];

  const gain = audioCtx.createGain();
  gain.gain.setValueAtTime(0, audioCtx.currentTime);
  gain.gain.linearRampToValueAtTime(0.15, audioCtx.currentTime + 0.02);

  const osc1 = audioCtx.createOscillator();
  const osc2 = audioCtx.createOscillator();
  osc1.type = 'sine';
  osc2.type = 'sine';
  osc1.frequency.value = freq1;
  osc2.frequency.value = freq2;

  osc1.connect(gain);
  osc2.connect(gain);
  gain.connect(audioCtx.destination);

  osc1.start();
  osc2.start();

  activePairs.set(id, {osc1, osc2, gain});
}

function stopNotePair(id) {
  const pair = activePairs.get(id);
  if (pair) {
    const now = audioCtx.currentTime;
    pair.gain.gain.cancelScheduledValues(now);
    pair.gain.gain.setValueAtTime(pair.gain.gain.value, now);
    pair.gain.gain.linearRampToValueAtTime(0.0, now + 0.03);
    pair.osc1.stop(now + 0.05);
    pair.osc2.stop(now + 0.05);
    activePairs.delete(id);
  }
}

function updateCollisions() {
  const touchingPairs = new Set();

  for (let i = 0; i < blocks.length; i++) {
    for (let j = i + 1; j < blocks.length; j++) {
      const a = blocks[i];
      const b = blocks[j];
      if (a.isCollidingWith(b)) {
        const id = a.getIdWith(b);
        touchingPairs.add(id);
        playNotePair(id, a.note, b.note);
      }
    }
  }

  // Stop any non-touching active notes
  for (let id of [...activePairs.keys()]) {
    if (!touchingPairs.has(id)) {
      stopNotePair(id);
    }
  }
}

function animate() {
  ctx.clearRect(0, 0, W, H);
  for (let b of blocks) {
    b.update();
    b.draw();
  }
  updateCollisions();
  requestAnimationFrame(animate);
}

function spawnBlocks() {
  for (let i = 0; i < NOTES.length; i++) {
    const x = 60 + i * (BLOCK_SIZE + 10);
    blocks.push(new Block(x, NOTES[i], COLORS[i % COLORS.length]));
  }
}

function enableDragging() {
  canvas.addEventListener('mousedown', (e) => {
    const mx = e.clientX;
    const my = e.clientY;
    for (let b of blocks) {
      if (mx >= b.x && mx <= b.x + b.width && my >= b.y && my <= b.y + b.height) {
        b.isDragging = true;
        b.dragOffset.x = mx - b.x;
        b.dragOffset.y = my - b.y;
        break;
      }
    }
  });

  canvas.addEventListener('mousemove', (e) => {
    const mx = e.clientX;
    const my = e.clientY;
    for (let b of blocks) {
      if (b.isDragging) {
        b.x = mx - b.dragOffset.x;
        b.y = my - b.dragOffset.y;
        b.vy = 0;
      }
    }
  });

  canvas.addEventListener('mouseup', () => {
    for (let b of blocks) {
      b.isDragging = false;
    }
  });
}

// Resize canvas on window resize
window.addEventListener('resize', () => {
  W = window.innerWidth;
  H = window.innerHeight;
  canvas.width = W;
  canvas.height = H;
});

spawnBlocks();
enableDragging();
animate();
</script>
</body>
</html>

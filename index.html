<!DOCTYPE html>
<html lang="en">
<head>
<meta charset="UTF-8" />
<meta name="viewport" content="width=device-width, initial-scale=1" />
<title>Chromatic Musical Blocks - Enhanced</title>
<style>
  body {
    margin: 0;
    background: #111;
    overflow: hidden;
    font-family: 'Segoe UI', Tahoma, Geneva, Verdana, sans-serif;
    touch-action: none;
  }
  canvas {
    display: block;
    background: #111;
  }
  .instructions {
    position: absolute;
    bottom: 20px;
    left: 0;
    right: 0;
    text-align: center;
    color: rgba(255,255,255,0.7);
    font-size: 14px;
    pointer-events: none;
  }
</style>
</head>
<body>
<canvas id="canvas"></canvas>
<div class="instructions">Drag and throw blocks to make music</div>

<script>
// Enhanced note configuration with more octaves
const NOTES = [
  'C3', 'C#3', 'D3', 'D#3', 'E3', 'F3',
  'F#3', 'G3', 'G#3', 'A3', 'A#3', 'B3',
  'C4', 'C#4', 'D4', 'D#4', 'E4', 'F4',
  'F#4', 'G4', 'G#4', 'A4', 'A#4', 'B4'
];

// More vibrant colors with better distribution
const COLORS = [
  '#FF4136', '#FF851B', '#FFDC00', '#2ECC40', '#39CCCC', '#0074D9',
  '#B10DC9', '#85144b', '#3D9970', '#7FDBFF', '#FF6347', '#FF4500',
  '#FF4136', '#FF851B', '#FFDC00', '#2ECC40', '#39CCCC', '#0074D9',
  '#B10DC9', '#85144b', '#3D9970', '#7FDBFF', '#FF6347', '#FF4500'
];

// Expanded frequency range
const NOTE_FREQS = {
  'C3': 130.81, 'C#3': 138.59, 'D3': 146.83, 'D#3': 155.56,
  'E3': 164.81, 'F3': 174.61, 'F#3': 185.00, 'G3': 196.00,
  'G#3': 207.65, 'A3': 220.00, 'A#3': 233.08, 'B3': 246.94,
  'C4': 261.63, 'C#4': 277.18, 'D4': 293.66, 'D#4': 311.13,
  'E4': 329.63, 'F4': 349.23, 'F#4': 369.99, 'G4': 392.00,
  'G#4': 415.30, 'A4': 440.00, 'A#4': 466.16, 'B4': 493.88
};

const canvas = document.getElementById('canvas');
const ctx = canvas.getContext('2d');
let W = window.innerWidth;
let H = window.innerHeight;
canvas.width = W;
canvas.height = H;

// Physics constants
const GRAVITY = 0.5;
const FRICTION = 0.98;
const BOUNCE = 0.6;
const BLOCK_SIZE = Math.min(60, W / 12);
const blocks = [];
const activePairs = new Map();
const activeNotes = new Map();
let audioCtx;
let masterGain;

// Initialize audio context on first interaction
function initAudio() {
  if (!audioCtx) {
    audioCtx = new (window.AudioContext || window.webkitAudioContext)();
    masterGain = audioCtx.createGain();
    masterGain.gain.value = 0.5;
    masterGain.connect(audioCtx.destination);
  }
}

class Block {
  constructor(x, note, color) {
    this.x = x;
    this.y = Math.random() * H * 0.25;
    this.vx = 0;
    this.vy = 0;
    this.width = BLOCK_SIZE;
    this.height = BLOCK_SIZE;
    this.note = note;
    this.color = color;
    this.isDragging = false;
    this.dragOffset = {x: 0, y: 0};
    this.lastMousePos = {x: 0, y: 0};
    this.lastMouseTime = 0;
    this.throwVelocity = {x: 0, y: 0};
    this.glowIntensity = 0;
    this.collisionCount = 0;
    this.rotation = Math.random() * Math.PI * 2;
    this.rotationSpeed = (Math.random() - 0.5) * 0.1;
  }

  draw() {
    // Save current context state
    ctx.save();
    
    // Move to block center for rotation
    ctx.translate(this.x + this.width/2, this.y + this.height/2);
    ctx.rotate(this.rotation);
    
    // Glow effect based on activity
    const glowSize = 15 + this.glowIntensity * 10;
    ctx.shadowColor = this.color;
    ctx.shadowBlur = glowSize;
    
    // Rounded rectangle with enhanced styling
    const radius = 12;
    const gradient = ctx.createLinearGradient(-this.width/2, -this.height/2, this.width/2, this.height/2);
    gradient.addColorStop(0, this.color);
    gradient.addColorStop(1, lightenColor(this.color, 20));
    
    ctx.fillStyle = gradient;
    ctx.beginPath();
    ctx.moveTo(-this.width/2 + radius, -this.height/2);
    ctx.lineTo(this.width/2 - radius, -this.height/2);
    ctx.quadraticCurveTo(this.width/2, -this.height/2, this.width/2, -this.height/2 + radius);
    ctx.lineTo(this.width/2, this.height/2 - radius);
    ctx.quadraticCurveTo(this.width/2, this.height/2, this.width/2 - radius, this.height/2);
    ctx.lineTo(-this.width/2 + radius, this.height/2);
    ctx.quadraticCurveTo(-this.width/2, this.height/2, -this.width/2, this.height/2 - radius);
    ctx.lineTo(-this.width/2, -this.height/2 + radius);
    ctx.quadraticCurveTo(-this.width/2, -this.height/2, -this.width/2 + radius, -this.height/2);
    ctx.closePath();
    ctx.fill();
    
    // Highlight when active
    if (this.glowIntensity > 0) {
      ctx.strokeStyle = lightenColor(this.color, 30);
      ctx.lineWidth = 2 + this.glowIntensity * 2;
      ctx.stroke();
    }
    
    // Text with better contrast
    ctx.shadowBlur = 0;
    ctx.fillStyle = '#fff';
    ctx.font = "bold " + Math.max(14, BLOCK_SIZE/3) + "px 'Segoe UI', Tahoma, Geneva, Verdana, sans-serif";
    ctx.textAlign = "center";
    ctx.textBaseline = "middle";
    ctx.fillText(this.note, 0, 0);
    
    // Restore context state
    ctx.restore();
  }

  update(deltaTime) {
    // Update rotation
    if (!this.isDragging) {
      this.rotation += this.rotationSpeed;
      
      // Apply throw velocity with friction
      this.vx += this.throwVelocity.x;
      this.vy += this.throwVelocity.y;

      // Gravity
      this.vy += GRAVITY;

      // Friction slows down throw velocity gradually
      this.throwVelocity.x *= FRICTION;
      this.throwVelocity.y *= FRICTION;

      // Update position
      this.x += this.vx;
      this.y += this.vy;

      // Boundaries with bounce
      if (this.x < 0) {
        this.x = 0;
        this.vx = -this.vx * BOUNCE;
        this.throwVelocity.x = -this.throwVelocity.x * BOUNCE;
        this.playNote();
      }
      if (this.x + this.width > W) {
        this.x = W - this.width;
        this.vx = -this.vx * BOUNCE;
        this.throwVelocity.x = -this.throwVelocity.x * BOUNCE;
        this.playNote();
      }

      // Floor collision
      if (this.y + this.height > H) {
        this.y = H - this.height;
        this.vy = -this.vy * BOUNCE;
        this.throwVelocity.y = -this.throwVelocity.y * BOUNCE;
        if (Math.abs(this.vy) > 1) this.playNote();
      }

      // Stack collision
      for (let other of blocks) {
        if (other !== this && this.isCollidingWith(other)) {
          this.resolveCollision(other);
        }
      }
    }
    
    // Decay glow intensity
    this.glowIntensity = Math.max(0, this.glowIntensity - 0.05);
  }

  isCollidingWith(other) {
    return this.x < other.x + other.width &&
           this.x + this.width > other.x &&
           this.y < other.y + other.height &&
           this.y + this.height > other.y;
  }

  resolveCollision(other) {
    // Calculate collision normal
    const dx = (other.x + other.width/2) - (this.x + this.width/2);
    const dy = (other.y + other.height/2) - (this.y + this.height/2);
    const distance = Math.sqrt(dx * dx + dy * dy);
    const minDist = (this.width + other.width) / 2;
    
    if (distance < minDist) {
      // Play notes on collision
      this.playNote();
      other.playNote();
      
      // Calculate overlap
      const overlap = minDist - distance;
      const nx = dx / distance;
      const ny = dy / distance;
      
      // Reposition blocks
      const moveX = nx * overlap * 0.5;
      const moveY = ny * overlap * 0.5;
      
      this.x -= moveX;
      this.y -= moveY;
      other.x += moveX;
      other.y += moveY;
      
      // Calculate relative velocity
      const relativeVx = other.vx - this.vx;
      const relativeVy = other.vy - this.vy;
      
      // Calculate impulse
      const velocityAlongNormal = relativeVx * nx + relativeVy * ny;
      
      // Do not resolve if objects are separating
      if (velocityAlongNormal > 0) return;
      
      // Calculate restitution (bounciness)
      const restitution = BOUNCE;
      
      // Calculate impulse scalar
      const j = -(1 + restitution) * velocityAlongNormal;
      const impulse = j / 2; // Divide by 2 for equal mass
      
      // Apply impulse
      const impulseX = nx * impulse;
      const impulseY = ny * impulse;
      
      this.vx -= impulseX;
      this.vy -= impulseY;
      other.vx += impulseX;
      other.vy += impulseY;
      
      // Also affect throw velocity
      this.throwVelocity.x -= impulseX * 0.5;
      this.throwVelocity.y -= impulseY * 0.5;
      other.throwVelocity.x += impulseX * 0.5;
      other.throwVelocity.y += impulseY * 0.5;
    }
  }

  getIdWith(other) {
    return [this.note, other.note].sort().join("-");
  }
  
  playNote() {
    if (!audioCtx) initAudio();
    
    // Increase glow when note plays
    this.glowIntensity = 1;
    
    // Play individual note
    if (!activeNotes.has(this.note)) {
      const osc = audioCtx.createOscillator();
      const gain = audioCtx.createGain();
      
      osc.type = 'sine';
      osc.frequency.value = NOTE_FREQS[this.note];
      gain.gain.value = 0;
      
      osc.connect(gain);
      gain.connect(masterGain);
      
      osc.start();
      
      // Smooth volume envelope
      gain.gain.setValueAtTime(0, audioCtx.currentTime);
      gain.gain.linearRampToValueAtTime(0.2, audioCtx.currentTime + 0.02);
      gain.gain.exponentialRampToValueAtTime(0.001, audioCtx.currentTime + 0.5);
      
      activeNotes.set(this.note, {osc, gain});
      
      // Automatically clean up after sound completes
      setTimeout(() => {
        if (activeNotes.has(this.note)) {
          activeNotes.get(this.note).osc.stop();
          activeNotes.delete(this.note);
        }
      }, 500);
    }
  }
}

function playNotePair(id, note1, note2) {
  if (activePairs.has(id)) return;
  if (!audioCtx) initAudio();

  const freq1 = NOTE_FREQS[note1];
  const freq2 = NOTE_FREQS[note2];

  const gain = audioCtx.createGain();
  gain.gain.value = 0;
  gain.connect(masterGain);

  const osc1 = audioCtx.createOscillator();
  const osc2 = audioCtx.createOscillator();
  osc1.type = 'sine';
  osc2.type = 'sine';
  osc1.frequency.value = freq1;
  osc2.frequency.value = freq2;

  osc1.connect(gain);
  osc2.connect(gain);

  // More musical envelope
  const now = audioCtx.currentTime;
  gain.gain.setValueAtTime(0, now);
  gain.gain.linearRampToValueAtTime(0.15, now + 0.02);
  gain.gain.exponentialRampToValueAtTime(0.001, now + 1.0);

  osc1.start();
  osc2.start();

  activePairs.set(id, {osc1, osc2, gain});

  // Automatically stop after 1 second if still active
  setTimeout(() => {
    if (activePairs.has(id)) {
      stopNotePair(id);
    }
  }, 1000);
}

function stopNotePair(id) {
  const pair = activePairs.get(id);
  if (pair) {
    const now = audioCtx.currentTime;
    pair.gain.gain.cancelScheduledValues(now);
    pair.gain.gain.setValueAtTime(pair.gain.gain.value, now);
    pair.gain.gain.linearRampToValueAtTime(0.0, now + 0.05);
    pair.osc1.stop(now + 0.1);
    pair.osc2.stop(now + 0.1);
    activePairs.delete(id);
  }
}

function updateCollisions() {
  const touchingPairs = new Set();

  for (let i = 0; i < blocks.length; i++) {
    for (let j = i + 1; j < blocks.length; j++) {
      const a = blocks[i];
      const b = blocks[j];
      if (a.isCollidingWith(b)) {
        const id = a.getIdWith(b);
        touchingPairs.add(id);
        playNotePair(id, a.note, b.note);
      }
    }
  }

  // Stop any non-touching active notes
  for (let id of [...activePairs.keys()]) {
    if (!touchingPairs.has(id)) {
      stopNotePair(id);
    }
  }
}

// Helper function to lighten colors
function lightenColor(color, percent) {
  const num = parseInt(color.replace("#", ""), 16);
  const amt = Math.round(2.55 * percent);
  const R = (num >> 16) + amt;
  const G = (num >> 8 & 0x00FF) + amt;
  const B = (num & 0x0000FF) + amt;
  return "#" + (
    0x1000000 + 
    (R < 255 ? R < 1 ? 0 : R : 255) * 0x10000 + 
    (G < 255 ? G < 1 ? 0 : G : 255) * 0x100 + 
    (B < 255 ? B < 1 ? 0 : B : 255)
  ).toString(16).slice(1);
}

let lastTime = 0;
function animate(time = 0) {
  const deltaTime = Math.min((time - lastTime) / 1000, 0.016); // Cap at 60fps
  lastTime = time;

  ctx.clearRect(0, 0, W, H);
  
  // Draw subtle grid
  ctx.strokeStyle = 'rgba(255,255,255,0.05)';
  ctx.lineWidth = 1;
  const gridSize = BLOCK_SIZE * 2;
  for (let x = 0; x < W; x += gridSize) {
    ctx.beginPath();
    ctx.moveTo(x, 0);
    ctx.lineTo(x, H);
    ctx.stroke();
  }
  for (let y = 0; y < H; y += gridSize) {
    ctx.beginPath();
    ctx.moveTo(0, y);
    ctx.lineTo(W, y);
    ctx.stroke();
  }
  
  // Update and draw blocks
  for (let b of blocks) {
    b.update(deltaTime);
    b.draw();
  }
  
  updateCollisions();
  requestAnimationFrame(animate);
}

function spawnBlocks() {
  blocks.length = 0;
  const blocksPerRow = Math.floor(W / (BLOCK_SIZE + 10));
  const startX = (W - (blocksPerRow * (BLOCK_SIZE + 10))) / 2 + BLOCK_SIZE/2;
  
  for (let i = 0; i < NOTES.length; i++) {
    const row = Math.floor(i / blocksPerRow);
    const col = i % blocksPerRow;
    const x = startX + col * (BLOCK_SIZE + 10);
    const y = 50 + row * (BLOCK_SIZE + 10);
    blocks.push(new Block(x, NOTES[i], COLORS[i % COLORS.length]));
  }
}

function enableDragging() {
  let draggingBlock = null;
  let lastMousePos = {x: 0, y: 0};
  let lastMouseTime = 0;

  function startDrag(mx, my) {
    // Iterate backwards so top blocks (drawn last) get priority
    for (let i = blocks.length -1; i >= 0; i--) {
      let b = blocks[i];
      if (mx >= b.x && mx <= b.x + b.width && my >= b.y && my <= b.y + b.height) {
        draggingBlock = b;
        b.isDragging = true;
        b.dragOffset.x = mx - b.x;
        b.dragOffset.y = my - b.y;
        b.vx = 0;
        b.vy = 0;
        b.throwVelocity = {x: 0, y: 0};
        b.lastMousePos = {x: mx, y: my};
        b.lastMouseTime = performance.now();
        // Bring dragged block to front
        blocks.splice(i, 1);
        blocks.push(b);
        // Play note on grab
        b.playNote();
        break;
      }
    }
  }

  function moveDrag(mx, my) {
    if (!draggingBlock) return;
    const now = performance.now();
    
    // Calculate velocity for throwing
    const dt = (now - draggingBlock.lastMouseTime) / 1000 || 0.016;
    draggingBlock.throwVelocity.x = (mx - draggingBlock.lastMousePos.x) / dt * 0.5;
    draggingBlock.throwVelocity.y = (my - draggingBlock.lastMousePos.y) / dt * 0.5;
    
    draggingBlock.x = mx - draggingBlock.dragOffset.x;
    draggingBlock.y = my - draggingBlock.dragOffset.y;
    draggingBlock.lastMousePos = {x: mx, y: my};
    draggingBlock.lastMouseTime = now;
  }

  function endDrag() {
    if (draggingBlock) {
      draggingBlock.isDragging = false;
      // Play note on release
      draggingBlock.playNote();
      draggingBlock = null;
    }
  }

  // Mouse events
  canvas.addEventListener('mousedown', (e) => {
    initAudio();
    startDrag(e.clientX, e.clientY);
  });

  canvas.addEventListener('mousemove', (e) => {
    moveDrag(e.clientX, e.clientY);
  });

  canvas.addEventListener('mouseup', endDrag);
  canvas.addEventListener('mouseleave', endDrag);

  // Touch events
  canvas.addEventListener('touchstart', (e) => {
    e.preventDefault();
    initAudio();
    if (e.touches.length > 0) {
      startDrag(e.touches[0].clientX, e.touches[0].clientY);
    }
  }, {passive: false});

  canvas.addEventListener('touchmove', (e) => {
    e.preventDefault();
    if (e.touches.length > 0) {
      moveDrag(e.touches[0].clientX, e.touches[0].clientY);
    }
  }, {passive: false});

  canvas.addEventListener('touchend', (e) => {
    e.preventDefault();
    endDrag();
  }, {passive: false});
}

// Resize handling
function handleResize() {
  W = window.innerWidth;
  H = window.innerHeight;
  canvas.width = W;
  canvas.height = H;
  spawnBlocks();
}

window.addEventListener('resize', handleResize);

// Initialize
handleResize();
enableDragging();
animate();

// Start audio context on any interaction
document.addEventListener('click', initAudio);
document.addEventListener('touchstart', initAudio);
</script>
</body>
</html>

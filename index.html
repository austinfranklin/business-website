<!DOCTYPE html>
<html lang="en">
<head>
<meta charset="UTF-8" />
<meta name="viewport" content="width=device-width, initial-scale=1, user-scalable=no" />
<title>Mobile-Friendly Synth Track Block</title>
<style>
  body {
    font-family: Arial, sans-serif;
    padding: 20px;
    background: #121212;
    color: #eee;
    display: flex;
    flex-direction: column;
    align-items: center;
    min-height: 100vh;
    margin: 0;
  }
  #track-container {
    background: #1f1f1f;
    padding: 20px;
    border-radius: 10px;
    width: 90vw;
    max-width: 400px;
    box-shadow: 0 0 20px #00ccff66;
    user-select: none;
  }
  button {
    display: block;
    width: 100%;
    margin: 12px 0;
    font-size: 1.3rem;
    padding: 15px;
    border: none;
    border-radius: 8px;
    background: #00ccff;
    color: #121212;
    font-weight: bold;
    cursor: pointer;
    transition: background 0.3s ease;
  }
  button:active {
    background: #0088cc;
  }
  label {
    margin-top: 15px;
    font-size: 1.1rem;
  }
  input[type=range] {
    width: 100%;
    margin-top: 8px;
    -webkit-appearance: none;
    background: #333;
    height: 8px;
    border-radius: 6px;
  }
  input[type=range]::-webkit-slider-thumb {
    -webkit-appearance: none;
    appearance: none;
    width: 24px;
    height: 24px;
    background: #00ccff;
    cursor: pointer;
    border-radius: 50%;
    margin-top: -8px;
  }
  input[type=range]:focus {
    outline: none;
  }
</style>
</head>
<body>

<h1>Mobile-Friendly Synth Track Block</h1>
<div id="track-container">
  <button id="change-sound-btn">Change Sound (sine)</button>
  
  <label for="attack-slider">Attack Time (seconds): <span id="attack-val">0.05</span></label>
  <input type="range" id="attack-slider" min="0.01" max="1" step="0.01" value="0.05" />
  
  <label for="release-slider">Release Time (seconds): <span id="release-val">0.3</span></label>
  <input type="range" id="release-slider" min="0.01" max="2" step="0.01" value="0.3" />
  
  <button id="play-btn">Play Note</button>
</div>

<script>
(() => {
  let audioContext;
  let isAudioStarted = false;

  // Mobile-compatible AudioContext creation
  function createAudioContext() {
    if (!audioContext) {
      audioContext = new (window.AudioContext || window.webkitAudioContext)();
    }
    return audioContext;
  }

  class Synth {
    constructor(ctx) {
      this.ctx = ctx;
      this.oscillator = null;
      this.gainNode = this.ctx.createGain();
      this.gainNode.gain.value = 0;
      this.gainNode.connect(this.ctx.destination);

      this.oscType = 'sine';
      this.attack = 0.05;
      this.release = 0.3;
    }

    setSound(type) {
      this.oscType = type || 'sine';
      if (this.oscillator) {
        this.oscillator.type = this.oscType;
      }
    }

    setEnvelope(attack, release) {
      this.attack = attack;
      this.release = release;
    }

    play(freq) {
      if (!this.oscillator) {
        this.oscillator = this.ctx.createOscillator();
        this.oscillator.type = this.oscType;
        this.oscillator.frequency.setValueAtTime(freq, this.ctx.currentTime);
        this.oscillator.connect(this.gainNode);
        this.oscillator.start();
      } else {
        this.oscillator.frequency.setValueAtTime(freq, this.ctx.currentTime);
      }

      const now = this.ctx.currentTime;
      this.gainNode.gain.cancelScheduledValues(now);
      this.gainNode.gain.setValueAtTime(0, now);
      this.gainNode.gain.linearRampToValueAtTime(1, now + this.attack);
    }

    stop() {
      if (!this.oscillator) return;
      const now = this.ctx.currentTime;
      this.gainNode.gain.cancelScheduledValues(now);
      this.gainNode.gain.setValueAtTime(this.gainNode.gain.value, now);
      this.gainNode.gain.linearRampToValueAtTime(0, now + this.release);
      setTimeout(() => {
        if (this.oscillator) {
          this.oscillator.stop();
          this.oscillator.disconnect();
          this.oscillator = null;
        }
      }, (this.release + 0.1) * 1000);
    }
  }

  // Setup UI and interaction logic
  function init() {
    createAudioContext();

    const synth = new Synth(audioContext);
    const container = document.getElementById('track-container');

    const soundBtn = document.getElementById('change-sound-btn');
    const playBtn = document.getElementById('play-btn');
    const attackSlider = document.getElementById('attack-slider');
    const releaseSlider = document.getElementById('release-slider');
    const attackVal = document.getElementById('attack-val');
    const releaseVal = document.getElementById('release-val');

    const sounds = ['sine', 'square', 'triangle', 'sawtooth'];
    let currentSoundIndex = 0;

    function updateSoundText() {
      soundBtn.textContent = `Change Sound (${sounds[currentSoundIndex]})`;
    }
    updateSoundText();

    // Unlock audio context on first interaction (mobile browsers)
    function startAudioContext() {
      if (!isAudioStarted) {
        audioContext.resume().then(() => {
          isAudioStarted = true;
        });
      }
    }

    // Cycle through oscillator types
    function cycleSound() {
      currentSoundIndex = (currentSoundIndex + 1) % sounds.length;
      const newSound = sounds[currentSoundIndex];
      synth.setSound(newSound);
      updateSoundText();
    }

    // Play or stop the synth note
    let isPlaying = false;
    function togglePlay() {
      if (!isAudioStarted) {
        audioContext.resume().then(() => {
          isAudioStarted = true;
          playNote();
        });
      } else {
        if (isPlaying) {
          synth.stop();
          playBtn.textContent = 'Play Note';
          isPlaying = false;
        } else {
          playNote();
        }
      }
    }

    function playNote() {
      synth.play(440); // Fixed frequency for demo
      playBtn.textContent = 'Stop Note';
      isPlaying = true;
    }

    // Update envelope params on slider change
    function updateAttack(e) {
      const val = parseFloat(e.target.value);
      synth.setEnvelope(val, synth.release);
      attackVal.textContent = val.toFixed(2);
    }
    function updateRelease(e) {
      const val = parseFloat(e.target.value);
      synth.setEnvelope(synth.attack, val);
      releaseVal.textContent = val.toFixed(2);
    }

    // Event listeners with touch and click support
    ['click', 'touchstart'].forEach(evt => {
      soundBtn.addEventListener(evt, e => {
        e.preventDefault();
        startAudioContext();
        cycleSound();
      }, { passive: false });

      playBtn.addEventListener(evt, e => {
        e.preventDefault();
        startAudioContext();
        togglePlay();
      }, { passive: false });
    });

    attackSlider.addEventListener('input', e => {
      updateAttack(e);
    });

    releaseSlider.addEventListener('input', e => {
      updateRelease(e);
    });

    // On page load, initialize envelope values
    synth.setEnvelope(parseFloat(attackSlider.value), parseFloat(releaseSlider.value));
  }

  // Setup interaction unlock for audio on mobile
  function setupStartAudioListener() {
    function startAudio() {
      if (!audioContext) createAudioContext();
      audioContext.resume().then(() => {
        isAudioStarted = true;
        window.removeEventListener('touchstart', startAudio);
        window.removeEventListener('click', startAudio);
      });
    }
    window.addEventListener('touchstart', startAudio, { passive: true });
    window.addEventListener('click', startAudio, { passive: true });
  }

  document.addEventListener('DOMContentLoaded', () => {
    setupStartAudioListener();
    init();
  });
})();
</script>

</body>
</html>
